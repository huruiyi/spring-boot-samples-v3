# 多数据源事务无法回滚的原因分析

## 核心问题

在当前实现中，多数据源场景下事务无法自动回滚的原因如下：

### 1. Spring事务机制

```
事务管理器(PlatformTransactionManager)
    ↓
绑定到DataSource
    ↓
每个DataSource = 一个独立的事务上下文
```

### 2. 当前架构的问题

```
TransactionTestService (没有 @Transactional)
    ↓
UserService (@DataSource(USER) → user_db)
    ↓
OrderService (@DataSource(ORDER) → order_db)
```

#### 问题点：

1. **数据源切换与事务隔离**
   - `@DataSource` 注解通过AOP切换数据源
   - 每次切换都会绑定到不同的DataSource
   - 不同DataSource = 不同的事务上下文

2. **动态数据源的局限性**
   ```
   DynamicDataSource extends AbstractRoutingDataSource
   └── determineCurrentLookupKey() 决定使用哪个DataSource
   └── 但事务是绑定在具体DataSource上的
   ```

3. **AOP执行顺序**
   ```
   DataSourceAspect (@Order(-1))
       ↓ 在最外层
   ├── 切换到USER数据源
   ├── 执行UserService方法
   └── 清除数据源上下文
   
   再次调用时：
   ├── 切换到ORDER数据源
   ├── 执行OrderService方法
   └── 清除数据源上下文
   ```
   - 每个Service调用是独立的事务
   - 没有统一的事务边界

## 事务回滚失败的具体场景

### 场景1：在TransactionTestService上加@Transactional

```java
@Transactional  // 只对默认数据源生效
public String createUserAndOrder(...) {
    userService.save(user);    // user_db，不在事务中
    orderService.save(order);  // order_db，不在事务中
    if (rollback) {
        throw new RuntimeException();
    }
}
```

**结果：**
- user_db的数据不会回滚
- order_db的数据不会回滚

### 场景2：在每个Service上加@Transactional

```java
@Service
@Transactional  // 只对user_db生效
@DataSource(DataSourceType.USER)
public class UserService {
    ...
}

@Service
@Transactional  // 只对order_db生效
@DataSource(DataSourceType.ORDER)
public class OrderService {
    ...
}
```

**结果：**
- UserService的每个方法都有独立事务
- OrderService的每个方法都有独立事务
- 但两个事务之间没有关联

## 为什么多数据源无法共享事务？

### 原因1：事务管理器的限制

```java
// Spring Boot默认配置
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```

- 一个事务管理器只管理一个DataSource
- 无法同时管理多个DataSource的事务

### 原因2：数据库连接的隔离

```
user_db → Connection1 → Transaction1
order_db → Connection2 → Transaction2
```

- 不同数据库使用不同的JDBC Connection
- 无法在一个Connection中跨库操作
- 事务无法跨Connection传播

### 原因3：MySQL的事务特性

```
MySQL事务特性：
- ACID特性在单个数据库实例内生效
- 跨库操作需要分布式事务
- 本地事务无法跨数据库传播
```

## 解决方案

### 方案1：单数据源事务（推荐用于简单场景）

```java
// 所有操作在同一个数据库中
@Transactional
public void createUserAndOrder() {
    userService.save(user);
    orderService.save(order);
}
```

**适用场景：**
- 不需要多数据源
- 所有表在同一个数据库中

### 方案2：编程式事务管理

```java
@Autowired
private PlatformTransactionManager transactionManager;

public void createUserAndOrder() {
    // 手动管理每个数据源的事务
    TransactionDefinition def = new DefaultTransactionDefinition();
    
    // user_db事务
    TransactionStatus status1 = transactionManager.getTransaction(def);
    try {
        userService.save(user);
        transactionManager.commit(status1);
    } catch (Exception e) {
        transactionManager.rollback(status1);
        throw e;
    }
    
    // order_db事务
    TransactionStatus status2 = transactionManager.getTransaction(def);
    try {
        orderService.save(order);
        transactionManager.commit(status2);
    } catch (Exception e) {
        transactionManager.rollback(status2);
        // 注意：这里user_db已经提交，无法回滚
        throw e;
    }
}
```

**局限性：**
- 仍然是独立事务
- 后面的操作失败，前面的无法回滚

### 方案3：分布式事务（推荐用于跨库场景）

#### 3.1 Seata框架

```
架构：
TransactionTestService (@GlobalTransactional)
    ↓
UserService (@Transactional)
    ↓
OrderService (@Transactional)
    ↓
Seata全局事务协调器
    ↓
多数据源事务统一管理
```

**特点：**
- AT模式：自动记录undo/redo日志
- TCC模式：手动实现补偿逻辑
- SAGA模式：长事务补偿

**实现步骤：**
```xml
<!-- pom.xml -->
<dependency>
    <groupId>io.seata</groupId>
    <artifactId>seata-spring-boot-starter</artifactId>
    <version>2.0.0</version>
</dependency>
```

```yaml
# application.yml
seata:
  enabled: true
  application-id: multi-db-demo
  tx-service-group: my_tx_group
  service:
    vgroup-mapping:
      my_tx_group: default
    grouplist:
      default: 127.0.0.1:8091
```

```java
@GlobalTransactional
public String createUserAndOrder(...) {
    userService.save(user);
    orderService.save(order);
    if (rollback) {
        throw new RuntimeException();
    }
}
```

**Seata回滚原理：**
1. 事务开始时，记录每个操作的undo日志
2. 提交前，将undo日志写入seata数据库
3. 如果异常，根据undo日志回滚所有操作
4. 支持跨数据源、跨服务的全局事务

#### 3.2 JTA (Java Transaction API)

```java
@Transactional
public String createUserAndOrder(...) {
    // 需要XA数据源
    userService.save(user);
    orderService.save(order);
}
```

**特点：**
- 标准的分布式事务协议
- 性能较低（两阶段提交）
- 配置复杂

### 方案4：业务补偿（推荐用于最终一致性）

```java
public String createUserAndOrder(...) {
    try {
        Long userId = userService.save(user);
        Long orderId = orderService.save(order);
        
        // 可能失败的操作
        riskyOperation();
        
        return "成功";
    } catch (Exception e) {
        // 补偿：手动删除已创建的数据
        if (userId != null) {
            userService.deleteById(userId);
        }
        if (orderId != null) {
            orderService.deleteById(orderId);
        }
        throw e;
    }
}
```

**适用场景：**
- 可以接受短暂的不一致
- 通过补偿逻辑保证最终一致性
- 不想引入分布式事务框架

## 当前项目建议

### 测试场景1：单数据源事务测试

```java
@Transactional  // 只测试user_db的事务
public void testSingleDataSourceTransaction() {
    userService.save(user1);
    userService.save(user2);  // 用户名重复，触发异常
    // user1会回滚
}
```

### 测试场景2：多数据源独立事务

```java
public void testMultiDataSource() {
    try {
        userService.save(user);  // user_db事务1
        orderService.save(order); // order_db事务2
        // 两个独立事务，无法同时回滚
    } catch (Exception e) {
        // 需要手动补偿
    }
}
```

### 测试场景3：跨库业务补偿

```java
public void testCompensation() {
    Long userId = null;
    Long orderId = null;
    try {
        userId = userService.save(user);
        orderId = orderService.save(order);
        
        // 模拟失败
        if (needRollback) {
            throw new RuntimeException();
        }
    } catch (Exception e) {
        // 补偿删除
        if (userId != null) {
            userService.deleteById(userId);
        }
        if (orderId != null) {
            orderService.deleteById(orderId);
        }
        throw e;
    }
}
```

## 总结

### 多数据源事务的核心结论

1. **本地事务无法跨数据源**
   - Spring的@Transactional只能管理单个DataSource
   - 不同DataSource使用不同的Connection
   - 无法在本地事务层面实现跨库一致性

2. **需要分布式事务**
   - Seata：阿里巴巴开源，社区活跃
   - JTA：标准但性能低
   - TCC：手动补偿，适合对性能要求高

3. **根据业务选择方案**
   - 单数据库：用@Transactional
   - 多数据库但可接受不一致：用补偿
   - 多数据库必须强一致：用Seata

### 当前项目的限制

- ✅ 实现了动态数据源切换
- ✅ 实现了注解式数据源选择
- ❌ 无法实现跨数据源的本地事务
- ❌ 需要引入分布式事务框架才能实现回滚
